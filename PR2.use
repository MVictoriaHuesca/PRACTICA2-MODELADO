model coches

enum TipoRevision {
    mantenimiento,
    reparacion
}

class Clock
 attributes
    NOW : Integer init = 0 -- POSIX representation starting at 0
    resolution: Integer init = 1 
end

class Ciudad
end

class Coche 
   attributes
      fechaMatriculacion : Integer -- ¿Es cuando se crea?
      --kmRecorridos : Real derive
      diasGarantia : Integer --cuando se matricula son 400 y cada día que pasa se le resta 1. Tmbn se ponen los q diga el taller oficial al hacer una revision ahi

      --para acceder a la ultima revision habria que mirar la fecha fin mas grande de las reparaciones que no son averias 
      --necesitaMantenimiento : Boolean derive:
      --que sea true si han pasado mas de 400 desde la matriculacion o mas de 100 de la ultima revision
end

class Viaje
   attributes
      fechaSalida : Integer
      fechaLlegada : Integer
      km : Real
end

class Revision 
   attributes
      fechaInicio : Integer
      fechaFin : Integer
      tipo : TipoRevision
end

--crear enumeracion

class Taller
end 

class TallerOficial < Taller
   attributes
      tiempoGarantia : Integer
end





-- Terminar y revisar cuando el diagrama de clases esté completo

-- ¿Cuando se conectan dos pares de ciudades es necesario crear dos relaciones ej: Madrid-Barcelona y Barcelona-Madrid?
-- Para que haya una conexión tiene que haber al menos dos ciudades, además una misma ciudad puede tener conexión con más ciudades (se considera un modelo con solo una ciudad)
associationclass Conexion between   
   Ciudad [0..*] role ciudadOrigen  
   Ciudad [0..*] role ciudadDestino
   attributes
      kmDistancia : Real
end

association CocheEnCiudad between
    Coche [0..*]   role coche      -- Una ciudad puede albergar indeterminados coches
    Ciudad [0..1]  role ciudad    -- Un coche solo puede estar en una ciudad (si no se encuentra viajando)
end

association ViajeCiudadOrigen between 
   Viaje[0..*] role viajeOrigen  -- Una ciudad origen puede estar asociada o no a varios viajes
   Ciudad [1] role ciudadViajeOrigen  -- Un viaje tiene que estar asociado a una ciudad
end

association ViajeCiudadDestino between 
   Viaje[0..*] role viajeDestino -- Una ciudad destino puede estar asociada o no a varios viajes
   Ciudad [1] role ciudadViajeDestino -- Un viaje tiene que estar asociado a una ciudad
end 

association CocheViaje between
   Coche[1] role coche  -- Un viaje es realizado por un coche
   Viaje [0..*] role viaje   --Un coche puede haber realizado ninguno o varios viajes
end

association TallerEnCiudad between
   Taller[0..*] role taller -- Una ciudad puede albergar indeterminados talleres
   Ciudad[1] role ciudad -- Un taller está en una ciudad
end

association CocheEnRevision between 
   Coche[1] role coche -- Una revisión se realiza a un solo coche
   Revision[0..*] role revision -- Un coche puede haber tenido ninguna o varias revisiones
end

association RevisionEnTaller between
   Revision[*] role revision  -- Un taller puede realizar muchas revisiones
   Taller[1] role taller   -- Una revisión se realiza en un solo taller
end


--INVARIANTES Y RESTRICCIONES

constraints

context Conexion
   -- Cada ciudad debe estar al menos a 5km de distancia de otra        !!!!
   inv DistanciaMinima: 
      self.kmDistancia >= 5
   
   -- Una conexión debe ser entre 2 ciudades diferentes  !!!
   inv ConexionCiudadesDiferentes:
      self.ciudadOrigen <> self.ciudadDestino
   

context Ciudad
   -- En cada ciudad habrá, a lo sumo, un taller oficial.     
   inv UnicoTallerOficial: 
      self.taller->select(t | t.oclIsTypeOf(TallerOficial))->size() <= 1

context Coche      
   -- Un coche se encontrará en todo momento bien realizando un solo viaje determinado o bien en una ciudad.   !!! 
   inv cocheViajandoOEnCiudad:
      (self.ciudad.oclIsUndefined() and self.viaje->select(v | v.fechaLlegada.oclIsUndefined())->size() = 1) or -- Está en viaje
      (not self.ciudad.oclIsUndefined() and self.viaje->forAll(v | not v.fechaLlegada.oclIsUndefined())) -- Está en ciudad
   
   --Este atributo indica que un coche necesita mantenimiento si ha pasado más de un año (100 días) desde su última revisión de 
   --mantenimiento o si tiene más de 400 días desde su matriculación sin ninguna revisión. Usamos ultimaRevision->isEmpty() para saber 
   --si no ha tenido revisiones, 
   --y Clock::now - self.ultimaRevision.fechaFin >= 100 para verificar el tiempo desde la última revisión de mantenimiento.
   -- ESTO SERIA ATRIBUTO DERIVADO inv necesitaMantenimiento:
   --   (Clock::now > self.fechaMatriculacion + 400) implies
   --   (self.ultimaRevision->isEmpty() or 
   --   (Clock::now - self.ultimaRevision.fechaFin >= 100))

   -- Dos viajes no pueden solaparse en el tiempo, pudiendo la fecha de llegada de un viaje coincidir con la fecha de salida del siguiente.
   inv CoherenciaViajes:    
      self.viaje->sortedBy(v | v.fechaSalida)->forAll(v1, v2 |
         v1 <> v2 and v1.fechaLlegada <= v2.fechaSalida implies
         v1.ciudadViajeDestino = v2.ciudadViajeOrigen)


   -- Solo una revisión en un momento dado      !!!
   inv RevisionUnica:
      self.revision->select(r | r.fechaFin.oclIsUndefined())->size() <= 1


context Viaje
   -- La fecha de llegada de un viaje tiene que ser posterior a la fecha de salida
   inv fechaLlegadaPosteriorFechaSalida: 
      --self.terminado implies self.fechaSalida <= self.fechaLlegada   -- más bien sería comprobar que hay fecha de llegada y si hay fecha de llegada se comprueba que sea mayor que la de salida
       not self.fechaLlegada.oclIsUndefined() implies self.fechaSalida <= self.fechaLlegada

   -- Ciudad destino y origen de un viaje deben ser diferentes
   inv ViajeCiudadesDistintas:
      self.ciudadViajeOrigen <> self.ciudadViajeDestino
   
   -- La ciudad origen de un viaje debe ser la ciudad en la que se encuentra el coche
   inv ViajeCiudadOrigenCoche:
      self.coche.ciudad = self.ciudadViajeOrigen

   -- ES UNA PRECONDICION DE VIAJE inv ViajeCiudadOrigenEnCiudadCoche:
       
   

context Revision

   --Todas las revisiones deben tener lugar después de que el coche se matriculase.
   inv RevisionPosteriorAMatriculacion: 
      self.coche.fechaMatriculacion <= self.fechaInicio

   -- Si un coche está siendo sometido a una revisión, entonces el coche debe encontrarse en la misma ciudad donde está el taller.
   inv RevisionMismaCiudadCoche:
      self.coche.ciudad = self.taller.ciudad

   -- Toda revisión debe tener fecha de inicio y fecha de fin
   inv RevisionFechaInicioFin:
      not self.fechaInicio.oclIsUndefined() and not self.fechaFin.oclIsUndefined()
   
   
   


   

   





 
-- Si el coche ha completado al menos un viaje y no se encuentra viajando, entonces debe encontrarse en la ciudad a la que llegó en su último viaje.




-- Dos viajes no pueden solaparse en el tiempo, es decir, un viaje debe ocurrir siempre después de otro, pudiendo la fecha de llegada de un viaje coincidir con la fecha de salida del siguiente.
-- Las ciudades de origen y destino de los viajes deben ser coherentes. Es decir, si un coche
--    realiza un viaje desde la ciudad A hasta la ciudad B, el próximo viaje debe partir desde la
--    ciudad B.

--PREGUNTAS-------------------------------------------------

---------------------------------------------
--    ¿ La fecha de matriculación de un coche como se determina, es el valor del reloj cuando se crea el coche 
--    o se introduce manualmente?
--   ¿Tenemos que comprobar también que la fecha de inicio de una revisión sea anterior a la de fin?
--    Un viaje y una revisión no pueden ocurrir a la vez (o si?), habría que compobar que para que empezar a hacer un
--   viaje no esté en revisión (no se si esto entra en el apartado a, puede que sea algo que se modele en el comportamiento después)
--   ¿Hay que hacer invariante que compruebe que el tipo de revisión es o de mantenimiento o de reparación (es decir no
--   es undefined?
-- ¿El invariante coherenciaViajes no se modelaria como precondición para iniciar un viaje?
-- Fecha salida y fecha llegada serían atributos derivados?
