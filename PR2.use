model coches

enum TipoRevision {
    mantenimiento,
    reparacion
}

class Clock
 attributes
    NOW : Integer init = 0 -- POSIX representation starting at 0
    resolution: Integer init = 1 
end

class Ciudad
end

class Coche 
   attributes
      fechaMatriculacion : Integer -- ¿Es cuando se crea?
      diasGarantia : Integer --cuando se matricula son 400 y cada día que pasa se le resta 1. Tmbn se ponen los q diga el taller oficial al hacer una revision ahi

      kmRecorridos : Real derive: -- Suma de los kilómetros de los viajes completados
        self.viaje->select(v | not v.fechaLlegada.oclIsUndefined())->collect(v | v.km)->sum();

      necesitaMantenimiento: Boolean derive: -- Indica si el coche requiere mantenimiento según su antigüedad o la última revisión anual
         if self.fechaMatriculacion + 400 >= Clock.allInstances()->any(true).NOW then
            false
         else
            let ultimaRevision: Revision = self.revision->select(r | r.tipo = TipoRevision::mantenimiento)->sortedBy(r | r.fechaFin)->last() in
               if ultimaRevision.oclIsUndefined() then true
               else Clock.allInstances()->any(true).NOW >= ultimaRevision.fechaFin + 100
               endif
         endif;

      enGarantia : Boolean derive: -- Indica si el coche sigue en garantía según su antigüedad o la última revisión en un taller oficial
         if self.fechaMatriculacion + 400 >= Clock.allInstances()->any(true).NOW then
            true
         else
            let ultimaRevision: Revision = self.revision->sortedBy(r | r.fechaFin)->last() in
               if ultimaRevision.oclIsUndefined() then false
               else 
                  ultimaRevision.taller.oclIsTypeOf(TallerOficial) and 
                  Clock.allInstances()->any(true).NOW <= ultimaRevision.fechaFin + 
                  ultimaRevision.taller.oclAsType(TallerOficial).tiempoGarantia
               endif
         endif;
end

class Viaje
   attributes
      fechaSalida : Integer
      fechaLlegada : Integer
      km : Real
end

class Revision 
   attributes
      fechaInicio : Integer
      fechaFin : Integer
      tipo : TipoRevision
end

class Taller
end 

class TallerOficial < Taller
   attributes
      tiempoGarantia : Integer
end

associationclass Conexion between   
   Ciudad [0..*] role ciudadOrigen  
   Ciudad [0..*] role ciudadDestino
   attributes
      kmDistancia : Real
end

association CocheEnCiudad between
    Coche [0..*]   role coche      -- Una ciudad puede albergar indeterminados coches
    Ciudad [0..1]  role ciudad    -- Un coche solo puede estar en una ciudad (si no se encuentra viajando)
end

association ViajeCiudadOrigen between 
   Viaje[0..*] role viajeOrigen  -- Una ciudad origen puede estar asociada o no a varios viajes
   Ciudad [1] role ciudadViajeOrigen  -- Un viaje tiene que estar asociado a una ciudad
end

association ViajeCiudadDestino between 
   Viaje[0..*] role viajeDestino -- Una ciudad destino puede estar asociada o no a varios viajes
   Ciudad [1] role ciudadViajeDestino -- Un viaje tiene que estar asociado a una ciudad
end 

association CocheViaje between
   Coche[1] role coche  -- Un viaje es realizado por un coche
   Viaje [0..*] role viaje   --Un coche puede haber realizado ninguno o varios viajes
end

association TallerEnCiudad between
   Taller[0..*] role taller -- Una ciudad puede albergar indeterminados talleres
   Ciudad[1] role ciudad -- Un taller está en una ciudad
end

association CocheEnRevision between 
   Coche[1] role coche -- Una revisión se realiza a un solo coche
   Revision[0..*] role revision -- Un coche puede haber tenido ninguna o varias revisiones
end

association RevisionEnTaller between
   Revision[*] role revision  -- Un taller puede realizar muchas revisiones
   Taller[1] role taller   -- Una revisión se realiza en un solo taller
end


--INVARIANTES Y RESTRICCIONES

constraints

context Conexion
   -- Cada ciudad debe estar al menos a 5km de distancia de otra        !!!!
   inv DistanciaMinima: 
      self.kmDistancia >= 5
   
   -- Una conexión debe ser entre 2 ciudades diferentes  !!!
   inv ConexionCiudadesDiferentes:
      self.ciudadOrigen <> self.ciudadDestino
   

context Ciudad
   -- En cada ciudad habrá, a lo sumo, un taller oficial.     
   inv UnicoTallerOficial: 
      self.taller->select(t | t.oclIsTypeOf(TallerOficial))->size() <= 1

context Coche      
   -- Un coche se encontrará en todo momento bien realizando un solo viaje determinado o bien en una ciudad.   !!! 
   inv cocheViajandoOEnCiudad:
      (self.ciudad.oclIsUndefined() and self.viaje->select(v | v.fechaLlegada.oclIsUndefined())->size() = 1) or -- Está en viaje
      (not self.ciudad.oclIsUndefined() and self.viaje->forAll(v | not v.fechaLlegada.oclIsUndefined())) -- Está en ciudad
   
   

   -- Dos viajes no pueden solaparse en el tiempo, pudiendo la fecha de llegada de un viaje coincidir con la fecha de salida del siguiente.
   inv CoherenciaViajes:    
      self.viaje->sortedBy(v | v.fechaSalida)->forAll(v1, v2 |
         v1 <> v2 and v1.fechaLlegada <= v2.fechaSalida implies
         v1.ciudadViajeDestino = v2.ciudadViajeOrigen)


   -- Solo una revisión en un momento dado      !!!
   inv RevisionUnica:
      self.revision->select(r | r.fechaFin.oclIsUndefined())->size() <= 1

   -- La fecha de llegada de un viaje tiene que ser posterior a la fecha de salida
   inv fechaLlegadaPosteriorFechaSalida: 
       self.viaje->forAll(v | not v.fechaLlegada.oclIsUndefined() implies v.fechaSalida <= v.fechaLlegada )
   
   -- Un coche debe estar en la ciudad en la que acabó su último viaje si no está viajando y ah realizado al menos un viaje
   inv CocheCiudadUltimoViaje:
      self.viaje->size()>0 and not self.ciudad.oclIsUndefined() implies 
      self.ciudad = self.viaje->sortedBy(fechaLlegada)->last().ciudadViajeDestino


context Viaje
   
   -- Ciudad destino y origen de un viaje deben ser diferentes
   inv ViajeCiudadesDistintas:
      self.ciudadViajeOrigen <> self.ciudadViajeDestino

   -- ES UNA PRECONDICION DE VIAJE inv ViajeCiudadOrigenEnCiudadCoche:

context Revision

   --Todas las revisiones deben tener lugar después de que el coche se matriculase.
   inv RevisionPosteriorAMatriculacion: 
      self.coche.fechaMatriculacion <= self.fechaInicio

   -- Si un coche está siendo sometido a una revisión, entonces el coche debe encontrarse en la misma ciudad donde está el taller.
   inv RevisionMismaCiudadCoche:       --!!!
      self.fechaFin.oclIsUndefined() implies self.taller.ciudad = self.coche.ciudad 

   -- Toda revisión debe tener fecha de inicio y fecha de fin  !!! creo que esto no hace falta
   --inv RevisionFechaInicioFin:
      --not self.fechaInicio.oclIsUndefined() and not self.fechaFin.oclIsUndefined()

--PREGUNTAS-------------------------------------------------

---------------------------------------------
--    ¿ La fecha de matriculación de un coche como se determina, es el valor del reloj cuando se crea el coche 
--    o se introduce manualmente?
--   ¿Tenemos que comprobar también que la fecha de inicio de una revisión sea anterior a la de fin?
--    Un viaje y una revisión no pueden ocurrir a la vez (o si?), habría que compobar que para que empezar a hacer un
--   viaje no esté en revisión (no se si esto entra en el apartado a, puede que sea algo que se modele en el comportamiento después)
--   ¿Hay que hacer invariante que compruebe que el tipo de revisión es o de mantenimiento o de reparación (es decir no
--   es undefined?
-- ¿El invariante coherenciaViajes no se modelaria como precondición para iniciar un viaje?
-- Fecha salida y fecha llegada serían atributos derivados?


--Este atributo indica que un coche necesita mantenimiento si ha pasado más de un año (100 días) desde su última revisión de 
   --mantenimiento o si tiene más de 400 días desde su matriculación sin ninguna revisión. Usamos ultimaRevision->isEmpty() para saber 
   --si no ha tenido revisiones, 
   --y Clock::now - self.ultimaRevision.fechaFin >= 100 para verificar el tiempo desde la última revisión de mantenimiento.
   -- ESTO SERIA ATRIBUTO DERIVADO inv necesitaMantenimiento:
   --   (Clock::now > self.fechaMatriculacion + 400) implies
   --   (self.ultimaRevision->isEmpty() or 
   --   (Clock::now - self.ultimaRevision.fechaFin >= 100))